# Agent Skills Philosophy

**Status:** Canonical Reference
**Last Updated:** 2025-11-25

> このドキュメントはAgent Skillsの本質的な位置づけと設計方針を定義します。

## 1. Agent Skillsとは何か

Agent Skillsは**エージェントに知識を与えるもの**です。

```
Agent Skill = 知識 + パターン + ベストプラクティス + (補助的な)ユーティリティ
```

### Agent Skillsの本質

| 要素 | 説明 | 例 |
|------|------|-----|
| **指示書** | タスクの実行手順 | "PDFからテキストを抽出する手順" |
| **パターン** | 再利用可能なコード構造 | Reactコンポーネントのテンプレート |
| **ベストプラクティス** | 推奨される方法論 | エラーハンドリングの方針 |
| **参照コード** | 実装例、サンプル | `scripts/example.py` |

### Agent Skillsが**ではない**もの

```
❌ 実行環境 (Execution Environment)
❌ サンドボックス (Sandbox)
❌ アプリケーションプラットフォーム
❌ 仮想マシン / コンテナ
```

**重要**: Agent Skillsは「実行環境を提供する」ものではなく、「エージェントが何かを達成するための知識を提供する」ものです。

## 2. 実行モデル: どこでコードを実行するか

### 2.1 基本原則

```
┌─────────────────────────────────────────────────────────────┐
│ ユーザーのプロジェクト (IDE / CLI Agent)                     │
│                                                             │
│  ├── src/                    ← コード生成先                 │
│  ├── .venv/                  ← 実行環境                     │
│  ├── output/                 ← 出力先                       │
│  └── ...                                                    │
│                                                             │
│  【ここが実行のメインコンテキスト】                          │
└─────────────────────────────────────────────────────────────┘
                    ↑
          エージェントがスキルの
          知識を使ってコード生成・実行
                    ↓
┌─────────────────────────────────────────────────────────────┐
│ SkillHub MCP Server                                         │
│                                                             │
│  ├── search_skills()   → スキル検索                         │
│  ├── load_skill()      → 指示書ロード + パス取得            │
│  └── read_skill_file() → 参照コード読み取り                 │
│                                                             │
│  【知識の提供元。実行環境ではない】                          │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 なぜユーザー側で実行すべきか

| MCP側で実行 | ユーザー側で実行 |
|-------------|------------------|
| ❌ 出力ファイルがMCP側に残る | ✅ 出力が直接プロジェクトに |
| ❌ ファイル転送が必要 | ✅ 転送不要 |
| ❌ 各スキルに.venv → 重い | ✅ プロジェクトの環境を使う |
| ❌ カスタマイズしにくい | ✅ 自由にカスタマイズ |
| ❌ MCPサーバーが肥大化 | ✅ MCPは軽量のまま |

### 2.3 コンテキストエンジニアリングの観点

**核心的な問い**: なぜパスを返すのか？なぜファイル内容を返さないのか？

```
❌ 非効率なパターン
┌─────────────────────────────────────────────────────────────┐
│ Agent Context Window (有限リソース)                          │
│                                                             │
│ [指示書: 500 tokens]                                        │
│ [scripts/extract.py の内容: 2000 tokens] ← 実行するだけなら不要│
│ [scripts/convert.py の内容: 1500 tokens] ← 実行するだけなら不要│
│ [会話履歴...]                                               │
│                                                             │
│ → コンテキストウィンドウを大量消費                           │
└─────────────────────────────────────────────────────────────┘

✅ 効率的なパターン
┌─────────────────────────────────────────────────────────────┐
│ Agent Context Window                                        │
│                                                             │
│ [指示書: 500 tokens]                                        │
│ [パス: /skills/pdf/scripts/extract.py: 20 tokens]           │
│ [会話履歴...]                                               │
│                                                             │
│ → パスだけ保持、実行時にローカルで直接実行                   │
└─────────────────────────────────────────────────────────────┘
```

**原則**:
- **実行するだけのファイル** → パスを渡す（内容をコンテキストに載せない）
- **理解・修正が必要なファイル** → 必要に応じて読み込む

**なぜこれが重要か**:

1. **コンテキストウィンドウは有限**
   - `read_skill_file` を繰り返すとコンテキストを大量消費
   - 実行するだけなら内容を読む必要がない

2. **スキルのスクリプトは「テスト済みアーティファクト」**
   - スキルが動作するなら、そのスクリプトも動作する
   - 中身を見なくても、パスで実行すれば結果が得られる

3. **効率的なワークフロー**
   ```
   # 非効率: ファイル内容をコンテキストに読み込んで実行
   content = read_skill_file("pdf", "scripts/extract.py")  # 2000 tokens消費
   # ... contentを見て何かする ...

   # 効率的: パスだけ取得して直接実行
   path = "/skills/pdf/scripts/extract.py"  # 20 tokens
   execute(f"python {path} --input doc.pdf")  # ローカルで実行
   ```

### 2.4 典型的なワークフロー

**効率的なパターン（推奨）**:
```
1. エージェント: search_skills("PDF処理")
2. SkillHub: PDFスキル + パスを返す
3. エージェント: load_skill("pdf")
4. SkillHub: 指示書(SKILL.md) + スクリプトパスを返す
5. エージェント: パスを使ってローカルで直接実行
   → python /skills/pdf/scripts/extract.py --input doc.pdf
```

**内容を見る必要がある場合のみ**:
```
# コードを理解・修正したい場合のみ read_skill_file を使う
5. エージェント: read_skill_file("pdf", "scripts/extract.py")
6. SkillHub: 参照コードを返す（コンテキスト消費）
7. エージェント: コードを理解し、カスタマイズしてユーザーのプロジェクトに生成
```

**ポイント**:
- 実行するだけならパスで十分（コンテキスト節約）
- 内容を見るのは理解・修正が必要な場合のみ

## 3. Path-Based Design (パスベース設計)

### 3.1 原則

スキルは**パスを返す**ことで、エージェントがローカルで参照・実行できるようにする。

**設計理由**:
1. **コンテキスト効率**: ファイル内容ではなくパスを返すことでトークン消費を最小化
2. **直接実行**: パスがあればローカル環境で即座に実行可能
3. **テスト済み保証**: スキル内のスクリプトは動作確認済みのアーティファクト

```python
# search_skills: 発見フェーズ（pathなし）
{"name": "pdf", "description": "PDF処理スキル", "score": 0.85}

# load_skill: 実行フェーズ（pathあり）
{
    "name": "pdf",
    "instructions": "...",
    "path": "/path/to/skills/pdf"   # ← スキルのディレクトリパス
}
# instructions 内で参照されるファイル（例: "run extract.py"）は
# path を使って解決: /path/to/skills/pdf/extract.py
```

### 3.2 パスの使い方

エージェントはパスを使って:

1. **直接実行** (最も効率的): ファイル内容を見ずにパスで実行
2. **参照**: 必要な場合のみコードを読んで学ぶ
3. **コピー**: カスタマイズが必要な場合、ユーザーのプロジェクトにコピー

```bash
# ✅ 効率的: パスで直接実行（コンテキスト消費なし）
python /path/to/skills/pdf/scripts/extract.py --input doc.pdf --output text.txt

# ⚠️ 必要な場合のみ: ファイル内容を読む（コンテキスト消費）
read_skill_file("pdf", "scripts/extract.py")
```

### 3.3 なぜMCP側で実行しないのか

```python
# ❌ MCP側で実行すると...
run_skill_command("pdf", "python scripts/extract.py input.pdf output.txt")
# → output.txt はMCPサーバー側に作られる
# → ユーザーのプロジェクトには直接届かない

# ✅ パスを使ってローカルで実行すると...
# エージェントがユーザーのプロジェクト内でコマンドを実行
python /skills/pdf/scripts/extract.py /user/project/input.pdf /user/project/output.txt
# → output.txt は直接ユーザーのプロジェクトに作られる
```

### 3.4 read_skill_file が有用な場面

`read_skill_file` はコンテキストを消費するが、以下の場合は有用:

| 場面 | 理由 |
|------|------|
| **コードの理解** | ロジックを把握してカスタマイズしたい |
| **テンプレートとして使用** | ユーザーのプロジェクトに類似コードを生成 |
| **デバッグ** | スキルの挙動を確認するためにコードを読む |
| **学習** | エージェントがパターンを学ぶ |

```
# ✅ 有用な使い方: コードを理解してカスタマイズ
content = read_skill_file("pdf", "scripts/extract.py")
# → contentを分析し、ユーザーの要件に合わせて修正版を生成

# ❌ 非効率な使い方: 実行するためだけに読む
content = read_skill_file("pdf", "scripts/extract.py")
# → contentを見るだけで、そのまま実行 → パスで直接実行すべき
```

**判断基準**:
- 「このファイルの中身を見る必要があるか？」
- Yes → `read_skill_file`
- No（実行するだけ）→ パスで直接実行

## 4. run_skill_commandの役割 [DISABLED BY DEFAULT]

> ⚠️ **デフォルト無効**: `run_skill_command` は `server.py` でコメントアウトされています。
> `load_skill` で取得した `path` を使って、エージェント自身のターミナルで直接実行してください。
>
> 有効化が必要な場合は `server.py` の該当行のコメントを解除してください。

### 4.1 限定的な用途

`run_skill_command`は**デフォルト無効の補助的ツール**であり、有効化した場合でも以下の用途に限定:

| 適切な使用 | 不適切な使用 |
|------------|--------------|
| ✅ シェルアクセスがないクライアント | ❌ 本番のコード実行 |
| ✅ スキルの動作確認・デモ | ❌ 複雑なアプリケーション |
| ✅ 小さなステートレス変換 | ❌ 状態を持つ処理 |

### 4.2 設計方針

```python
# run_skill_commandの推奨される使い方
# - 入出力パスを明示的に指定
# - ステートレス（状態を持たない）
# - 小さな単一タスク

run_skill_command(
    skill="image-utils",
    command="python scripts/resize.py",
    args=["--input", "/absolute/path/input.png",
          "--output", "/absolute/path/output.png",
          "--size", "800x600"]
)
```

### 4.3 実行モデル: uv run + PEP 723

**実行方法**:
```
run_skill_command
├── uv がある場合: uv run python script.py
└── uv がない場合: python3 script.py (フォールバック)
```

**PEP 723 (Inline Script Metadata)**:

スクリプトが外部依存を必要とする場合、PEP 723 形式でインライン宣言できる:

```python
# /// script
# requires-python = ">=3.11"
# dependencies = [
#   "pypdf",
#   "pillow",
# ]
# ///

import pypdf
from PIL import Image

def process_pdf(path):
    ...
```

`uv run script.py` を実行すると:
1. uv が依存を読み取る
2. 一時的な環境を作成
3. 依存をインストール
4. スクリプト実行

**メリット**:
- スクリプトが自己完結（依存を自分で宣言）
- `.venv` 管理不要
- uv が全て処理

**対応マトリクス**:

| uv | スクリプト | 結果 |
|----|-----------|------|
| ✅ あり | stdlib のみ | ✅ 動く |
| ✅ あり | PEP 723 依存 | ✅ 動く |
| ❌ なし | stdlib のみ | ✅ 動く |
| ❌ なし | PEP 723 依存 | ❌ ImportError |

## 5. スキルの共有モデル

### 5.1 Git-Based Management

```
skillhub-skills/                    # スキルリポジトリ
├── pdf/
│   ├── SKILL.md
│   └── scripts/
├── web-artifacts-builder/
│   ├── SKILL.md
│   └── scripts/
└── ...
```

- **ローカル管理**: ユーザーが自分のマシンにスキルをclone
- **共有**: GitHubで共有・バージョン管理
- **カスタマイズ**: フォークして自分用に調整

### 5.2 SkillHubの役割

```
SkillHub MCP Server
├── スキルのインデックス作成
├── 検索・発見
├── 指示書のロード
└── パスの提供
```

**SkillHubは**:
- スキルを**見つける**ためのもの
- スキルの内容を**読む**ためのもの
- スキルを**実行する**ためのものではない（補助的にのみ）

## 6. 設計ガイドライン

### 6.1 スキル作成者向け

1. **指示書を充実させる**: SKILL.mdに詳細な手順を書く
2. **参照コードを提供**: scripts/に実装例を置く
3. **実行環境に依存しない**: MCP側の環境を前提としない
4. **パスで参照可能に**: 相対パスで構造化

```markdown
# 良いスキルの構造
my-skill/
├── SKILL.md           # 詳細な指示書
├── scripts/
│   ├── example.py     # 参照用コード
│   └── utils.py       # ユーティリティ
└── templates/         # テンプレート
    └── config.yaml
```

### 6.2 エージェント実装者向け

1. **load_skillで指示を得る**: まず指示書を読む
2. **read_skill_fileで参照**: 必要なコードを読む
3. **ユーザー側で実行**: コード生成・実行はユーザーのプロジェクトで
4. **run_skill_commandは補助的に**: 本当に必要な場合のみ

## 7. まとめ

```
Agent Skills = 知識の提供
SkillHub MCP = 知識へのアクセス手段
実行 = ユーザーのプロジェクト側
```

**Remember**:
- スキルは「教える」もの、「実行する」ものではない
- MCPサーバーは軽量に保つ
- 出力はユーザーのプロジェクトに直接
- パスベースでローカル実行を可能に
